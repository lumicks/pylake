import numpy as np
import skimage


class ColorAdjustment:
    """Utility class to adjust the min/max values of image colormaps.

    Values can be supplied as a single number or 1-component list, in which case the value is
    applied to all color channels, or a 3-component list specifying the values for red, green,
    and blue channels.

    Parameters
    ----------
    minimum : array_like
        1 or 3-component list of lower limits for the color mapping
    maximum : array_like
        1 or 3-component list of upper limits for the color mapping
    mode : str
        - "percentile" : color limits are given as percentiles of the image in question.
          Percentiles are calculated for each color channel separately
        - "absolute" : color limits are given as absolute values.

        Note: When providing bounds in percentiles, limits will change depending on which image
        you are looking at. When scrolling through a stack of images, the limits will not remain
        constant.
    gamma : float
        1 or 3-component list of gamma adjustments.

        Applies a power law to the data according to: `((data - vmin) / (vmax - vmin)) ** gamma`

    Examples
    --------
    ::

        from lumicks import pylake
        file = pylake.File("example.h5")

        # Plot scan with red color mapped from 5th to 95th percentile.
        adjustment = lk.ColorAdjustment(5, 95, mode="percentile")
        file.scans["scan"].plot(channel="red", adjustment=adjustment)

        # Plot scan with RGB colors mapped from 5th to 95th percentile.
        adjustment = lk.ColorAdjustment([5, 5, 5], [95, 95, 95], mode="percentile")
        file.scans["scan"].plot(adjustment=adjustment)

        stack = lk.ImageStack("camera_recording.tiff")
        # Plot force 1x with this stack and adjust the contrast by specifying an absolute upper
        # and lower bound for the intensities.
        absolute_adjustment = lk.ColorAdjustment([50, 30, 20], [1000, 195, 95])
        stack.plot_correlated(file.force1x, channel="rgb", adjustment=absolute_adjustment)
    """

    def __init__(self, minimum, maximum, mode="absolute", gamma=1):
        minimum, maximum, gamma = (np.atleast_1d(x) for x in (minimum, maximum, gamma))
        self.mode = None if mode == "nothing" else mode
        if not self.mode:
            return

        for bound in (minimum, maximum, gamma):
            if len(bound) not in (1, 3):
                raise ValueError("Color value bounds and gamma should be of length 1 or 3")

        if mode not in ("percentile", "absolute"):
            raise ValueError("Mode must be percentile or absolute")

        self.minimum, self.maximum = minimum * np.ones((3,)), maximum * np.ones((3,))
        self.gamma = gamma * np.ones((3,))

    def _get_data_rgb(self, image, channel="rgb"):
        """Scale RGB data for plotting.

        Parameters
        ----------
        image : array_like
            Raw image data.
        """
        if len(channel) == 2:
            missing_channel = set("rgb") - set(channel)
            missing_channel_index = "rgb".index(missing_channel.pop())
            image[:, :, missing_channel_index] = 0

        if not self.mode:
            return image / np.max(image)
        elif self.mode == "absolute":
            minimum, maximum = self.minimum, self.maximum
        else:
            bounds = np.array(
                [
                    np.percentile(img, [mini, maxi])
                    for img, mini, maxi in zip(np.moveaxis(image, 2, 0), self.minimum, self.maximum)
                ]
            )
            minimum, maximum = bounds.T

        denominator = maximum - minimum
        denominator[denominator == 0] = 1.0  # prevent div by zero
        return np.clip((image - minimum) / denominator, 0.0, 1.0) ** self.gamma

    def _update_limits(self, image_handle, image, channel):
        """Update color limits on an image generated by :func:`matplotlib.pyplot.imshow`

        Parameters
        ----------
        image_handle : matplotlib.image.AxesImage
            Image handle to apply color limits to
        image : array_like
            Raw image data.
        channel : str
            Channel that's being plotted (e.g. "red" or "rgb").
        """
        import matplotlib as mpl

        if not self.mode:
            return

        # Single channel images can come in any of the channel parameters but should be treated
        # as though a single channel was sliced.
        if channel in ("rgb", "rg", "gb", "rb") and image.ndim == 3:
            return

        color_mapping = {"red": 0, "green": 1, "blue": 2, "r": 0, "g": 1, "b": 2}
        idx = color_mapping.get(channel, 0)  # The default of zero is for monochrome images
        limits = (self.minimum[idx], self.maximum[idx])
        if self.mode == "percentile":
            limits = np.percentile(image, limits)

        image_handle.set_norm(
            norm=mpl.colors.PowerNorm(vmin=limits[0], vmax=limits[1], gamma=self.gamma[idx])
        )

    @classmethod
    def nothing(cls):
        return cls(None, None, "nothing")


no_adjustment = ColorAdjustment.nothing()


def wavelength_to_xyz(wavelength):
    """Calculate XYZ components in CIE color space."""
    conversion_coefficients = {
        "x": {
            "alpha": np.array([0.362, 1.056, -0.065]),
            "beta": np.array([442.0, 599.8, 501.1]),
            "gamma": np.array([0.0624, 0.0264, 0.0490]),
            "delta": np.array([0.0374, 0.0323, 0.0382]),
        },
        "y": {
            "alpha": np.array([0.821, 0.286]),
            "beta": np.array([568.8, 530.9]),
            "gamma": np.array([0.0213, 0.0613]),
            "delta": np.array([0.0247, 0.0322]),
        },
        "z": {
            "alpha": np.array([1.217, 0.681]),
            "beta": np.array([437.0, 459.0]),
            "gamma": np.array([0.0845, 0.0385]),
            "delta": np.array([0.0278, 0.0725]),
        },
    }

    def calculate_component(alpha, beta, gamma, delta):
        lam_min_beta = wavelength - beta
        s_func = np.where(lam_min_beta < 0, gamma, delta)
        return np.sum(alpha * np.exp(-0.5 * (lam_min_beta * s_func) ** 2))

    xyz = [
        calculate_component(**conversion_coefficients[key])
        for key in conversion_coefficients.keys()
    ]
    return np.hstack(xyz)


def _make_cmap(name, color):
    from matplotlib.colors import LinearSegmentedColormap

    return LinearSegmentedColormap.from_list(name, colors=[(0, 0, 0), color])


_available_colormaps = {
    "red": (1, 0, 0),
    "green": (0, 1, 0),
    "blue": (0, 0, 1),
    "magenta": (1, 0, 1),
    "yellow": (1, 1, 0),
    "cyan": (0, 1, 1),
}


class _ColorMaps:
    """Pylake custom colormaps.

    Attributes
    ----------
    red
    green
    blue
    magenta
    yellow
    cyan

    Methods
    -------
    from_wavelength(wavelength)
        Generate a colormap with a minimum of black and maximum color approximately
        corresponding to a wavelength in nanometers.

        RGB value approximating the given wavelength is calculated using Eq. 4 from [1]_.

        Parameters
        ----------
        wavelength: int
            wavelength to approximate maximum color from

        References
        ----------
        .. [1] Chris Wyman, Peter-Pike Sloan, Peter Shirley. "Simple Analytic Approximations to the
               CIE XYZ Color Matching Functions" Journal of Computer Graphics Techniques (2013) 2, 1-11.

    Examples
    --------
    ::

        # plot the blue image from a kymograph with cyan colormap
        kymo.plot(channel="blue", cmap=lk.colormaps.cyan)

        # plot the blue image with the emission maximum of the fluorophore excited at 488 nm
        kymo.plot(channel="blue", cmap=lk.colormaps.from_wavelength(521))
    """

    def __getattr__(self, name):
        if name not in _available_colormaps:
            raise AttributeError
        return _make_cmap(name, _available_colormaps[name])

    def __str__(self):
        return f"Pylake custom colormaps; available colormaps:\n\t{', '.join(_available_colormaps.keys())}"

    @property
    def rgb(self):
        return None

    def from_wavelength(self, wavelength):
        xyz = wavelength_to_xyz(wavelength)
        rgb = skimage.color.xyz2rgb(xyz.reshape([1, 1, 3])).squeeze()
        return _make_cmap(f"{wavelength}nm", rgb)

    def _get_default_colormap(self, channel):
        try:
            return getattr(self, channel)
        except AttributeError:
            if channel in (channel_shorthand := {"r": "red", "g": "green", "b": "blue"}):
                return getattr(self, channel_shorthand[channel])
            else:
                return self.rgb


colormaps = _ColorMaps()
